[{"name":"app.R","content":"#!/usr/bin/env Rscript\n\n###############################################################################\n# -*- encoding: UTF-8 -*-                                                     #\n# Author: Jesse C. Chen (website: jessekelighine.com)                         #\n# Description: Reverse Polish Notation                                        #\n#                                                                             #\n# Last Modified: 2025-04-13                                                   #\n###############################################################################\nlibrary(shiny)\nlibrary(fastmap)\n###############################################################################\n\noperator <- list()\nparse <- list()\n\n## Parsing ####################################################################\n\nparse$split <- function(command) strsplit(command, split = \" +\")[[1]]\n\nparse$is_negative <- function(str) substr(str, start = 1, stop = 1) == \"-\"\n\nparse$is_operator <- function(item) item %in% names(operator)\n\nparse$is_operand <- function(item) {\n  grepl(\n    pattern = \"^[-]{0,1}(([0-9]*\\\\.){0,1}[0-9]+|[a-zA-Z])$\",\n    x = item\n  )\n}\n\nparse$is_symbolic <- function(item) {\n  grepl(pattern = \"^[-]{0,1}[a-zA-Z]$\", x = item)\n}\n\n## Operators ##################################################################\n\noperator[[\"+\"]] <- list()\noperator[[\"+\"]]$n <- 2\noperator[[\"+\"]]$eval <- function(operand) {\n  as.numeric(operand[1]) + as.numeric(operand[2])\n}\noperator[[\"+\"]]$infix <- function(operator, infix) {\n  if (parse$is_negative(infix[2])) {\n    infix[2] <- paste0(\"\\\\left(\", infix[2], \"\\\\right)\")\n  }\n  list(infix = paste(infix[1], \"+\", infix[2]), operator = \"+\")\n}\n\noperator[[\"-\"]] <- list()\noperator[[\"-\"]]$n <- 2\noperator[[\"-\"]]$eval <- function(operand) {\n  as.numeric(operand[1]) - as.numeric(operand[2])\n}\noperator[[\"-\"]]$infix <- function(operator, infix) {\n  if (parse$is_negative(infix[2]) || operator[2] %in% c(\"+\", \"-\")) {\n    infix[2] <- paste0(\"\\\\left(\", infix[2], \"\\\\right)\")\n  }\n  list(infix = paste(infix[1], \"-\", infix[2]), operator = \"-\")\n}\n\noperator[[\"*\"]] <- list()\noperator[[\"*\"]]$n <- 2\noperator[[\"*\"]]$eval <- function(operand) {\n  as.numeric(operand[1]) * as.numeric(operand[2])\n}\noperator[[\"*\"]]$infix <- function(operator, infix) {\n  if (operator[1] %in% c(\"+\", \"-\")) {\n    infix[1] <- paste0(\"\\\\left(\", infix[1], \"\\\\right)\")\n  }\n  if (parse$is_negative(infix[2]) || operator[2] %in% c(\"+\", \"-\")) {\n    infix[2] <- paste0(\"\\\\left(\", infix[2], \"\\\\right)\")\n  }\n  list(infix = paste(infix[1], \"\\\\cdot\", infix[2]), operator = \"*\")\n}\n\noperator[[\"/\"]] <- list()\noperator[[\"/\"]]$n <- 2\noperator[[\"/\"]]$eval <- function(operand) {\n  as.numeric(operand[1]) / as.numeric(operand[2])\n}\noperator[[\"/\"]]$infix <- function(operator, infix) {\n  list(\n    infix = paste(\"\\\\frac{\", infix[1], \"}{\", infix[2], \"}\"),\n    operator = \"/\"\n  )\n}\n\noperator[[\"^\"]] <- list()\noperator[[\"^\"]]$n <- 2\noperator[[\"^\"]]$eval <- function(operand) {\n  as.numeric(operand[1])^as.numeric(operand[2])\n}\noperator[[\"^\"]]$infix <- function(operator, infix) {\n  if (parse$is_negative(infix[1]) || !parse$is_operand(infix[1])) {\n    infix[1] <- paste0(\"\\\\left(\", infix[1], \"\\\\right)\")\n  }\n  infix_output <- paste0(infix[1], \"^{\", infix[2], \"}\")\n  list(infix = infix_output, operator = \"^\")\n}\n\noperator[[\"!\"]] <- list()\noperator[[\"!\"]]$n <- 1\noperator[[\"!\"]]$eval <- function(operand) factorial(as.numeric(operand))\noperator[[\"!\"]]$infix <- function(operator, infix) {\n  infix_output <- if (parse$is_negative(infix) || !parse$is_operand(operator)) {\n    paste0(\"\\\\left(\", infix, \"\\\\right)!\")\n  } else {\n    paste0(infix, \"!\")\n  }\n  list(infix = infix_output, operator = \"!\")\n}\n\noperator[[\"sqrt\"]] <- list()\noperator[[\"sqrt\"]]$n <- 1\noperator[[\"sqrt\"]]$eval <- function(operand) sqrt(as.numeric(operand))\noperator[[\"sqrt\"]]$infix <- function(operator, infix) {\n  infix_output <- paste0(\"\\\\sqrt{\", infix, \"}\")\n  list(infix = infix_output, operator = \"sqrt\")\n}\n\noperator[[\"|\"]] <- list()\noperator[[\"|\"]]$n <- 2\noperator[[\"|\"]]$eval <- function(operand) {\n  c(as.numeric(operand[2]), as.numeric(operand[1]))\n}\noperator[[\"|\"]]$infix <- function(operator, infix) {\n  list(infix = infix[2:1], operator = operator[2:1])\n}\n\noperator[[\"~\"]] <- list()\noperator[[\"~\"]]$n <- 1\noperator[[\"~\"]]$eval <- function(operand) -as.numeric(operand)\noperator[[\"~\"]]$infix <- function(operator, infix) {\n  infix_output <- if (parse$is_negative(infix) || operator %in% c(\"+\", \"-\")) {\n    paste0(\"-\\\\left(\", infix, \"\\\\right)\")\n  } else {\n    paste0(\"-\", infix)\n  }\n  list(infix = infix_output, operator = \"~\")\n}\n\n## Main Functions #############################################################\n\nmain <- function(command) {\n  command <- gsub(pattern = \"(^\\\\s+|\\\\s+$)\", replacement = \"\", x = command)\n  stack <- list()\n  stack$value <- faststack()\n  stack$infix <- faststack()\n  stack$operator <- faststack()\n  for (item in parse$split(command)) {\n    if (parse$is_operand(item)) {\n      stack$value$push(item)\n      stack$infix$push(item)\n      stack$operator$push(\"atom\")\n      next\n    }\n    if (parse$is_operator(item)) {\n      if (stack$value$size() < operator[[item]]$n) {\n        error_message <- paste(\n          \"ERROR: Not enough operands for\",\n          paste0('\"', item, '\"')\n        )\n        return(list(value = error_message, infix = error_message))\n      }\n      operand <- stack$value$mpop(operator[[item]]$n) |> unlist() |> rev()\n      infix <- stack$infix$mpop(operator[[item]]$n) |> unlist() |> rev()\n      operators <- stack$operator$mpop(operator[[item]]$n) |> unlist() |> rev()\n      output_value <- operator[[item]]$eval(operand)\n      output_infix <- operator[[item]]$infix(operators, infix)\n      stack$value$mpush(.list = as.list(output_value))\n      stack$infix$mpush(.list = as.list(output_infix$infix))\n      stack$operator$mpush(.list = as.list(output_infix$operator))\n      next\n    }\n    error_message <- paste(\n      \"ERROR: Input\",\n      paste0('\"', item, '\"'),\n      \"is not a legal command\"\n    )\n    return(list(value = error_message, infix = error_message))\n  }\n  return(list(\n    value = stack$value$as_list() |> unlist(),\n    infix = stack$infix$as_list() |> unlist()\n  ))\n}\n\n## Shiny ######################################################################\n\nstyle_sheet <- paste(\n  \"width: auto;\",\n  \"max-width: 55em;\",\n  \"margin: 0 auto;\",\n  \"font-family: monospace;\"\n)\n\nui <- fluidPage(\n  includeCSS(\"www/style.css\"),\n  verticalLayout(\n    div(\n      style = style_sheet,\n      withMathJax(),\n      h3(strong(\"Reverse Polish Notation Calculator\")),\n      shiny::HTML(\n        paste(\n          \"<p>\",\n          \"Created by Jesse C. Chen\",\n          paste0(\n            \"(\",\n            \"<a href='https://jessekelighine.com'>jessekelighine.com<\/a>\",\n            \")\"\n          ),\n          \"<\/p>\"\n        )\n      ),\n      br(),\n      textInput(inputId = \"command\", label = \"RPN Input\"),\n      uiOutput(\"result\"),\n      includeHTML(\"www/body.html\")\n    )\n  )\n)\n\nserver <- function(input, output) {\n  output$result <- renderUI({\n    result <- main(input$command) |> lapply(\\(x) paste(x, collapse = \", \"))\n    zero_width_space <- \"\\u200B\"\n    if (result$value == \"\") result$value <- zero_width_space\n    if (result$infix == \"\") {\n      result$infix <- zero_width_space\n    } else if (!grepl(\"ERROR\", result$infix)) {\n      result$infix <- paste0(\"\\\\[\", result$infix, \"\\\\]\")\n    }\n    withMathJax(\n      strong(\"Output (Stack):\"),\n      br(),\n      result$value,\n      br(),\n      strong(\"Infix Notation:\"),\n      br(),\n      result$infix\n    )\n  })\n}\n\nshinyApp(ui = ui, server = server)\n","type":"text"},{"name":"Makefile","content":".PHONY: all clean\n\nall: www/body.html\n\nwww/body.html: www/body.md\n\tpandoc www/body.md -o www/body.html\n\nclean: \n\trm -rf www/*.html\n","type":"text"},{"name":"www/body.html","content":"<hr />\n<h4 id=\"usage\">Usage<\/h4>\n<p>Enter an expression in Reverse Polish Notation (RPN) to see its\nresult and corresponding infix notation.<\/p>\n<p><strong>Note<\/strong>: Make sure to separate each operand and\noperator with a space. Scroll down for usage examples.<\/p>\n<h4 id=\"available-operators\">Available Operators<\/h4>\n<ul>\n<li><code>+<\/code> <strong>ADD<\/strong>: <em>add<\/em> the last two\nnumbers on stack.<\/li>\n<li><code>-<\/code> <strong>SUBTRACT<\/strong>: <em>subtract<\/em> the last\ntwo numbers on stack.<\/li>\n<li><code>*<\/code> <strong>MULTIPLY<\/strong>: <em>multiply<\/em> the last\ntwo numbers on stack.<\/li>\n<li><code>/<\/code> <strong>DIVIDE<\/strong>: <em>divide<\/em> the last two\nnumbers on stack.<\/li>\n<li><code>^<\/code> <strong>POWER<\/strong>: raise the second-to-last\nnumber to the <em>power<\/em> of the last number on stack.<\/li>\n<li><code>!<\/code> <strong>FACTORIAL<\/strong>: calculate the\n<em>factorial<\/em> of the last number on stack.<\/li>\n<li><code>~<\/code> <strong>NEGATE<\/strong>: <em>negate<\/em> the last\nnumber on stack.<\/li>\n<li><code>sqrt<\/code> <strong>SQUARE ROOT<\/strong>: calculate the\n<em>square root<\/em> of the last number on stack.<\/li>\n<li><code>|<\/code> <strong>SWAP<\/strong>: <em>swap<\/em> the positions of\nthe last two number on stack.<\/li>\n<\/ul>\n<h4 id=\"available-operands\">Available Operands<\/h4>\n<ul>\n<li>You can use numbers or letters as <em>variables<\/em> (<code>a<\/code>\nto <code>z<\/code> and <code>A<\/code> to <code>Z<\/code>).<\/li>\n<li>If <em>variables<\/em> are used, the output will show a symbolic\ninfix expression, and the numeric result will be marked as\n<code>NA<\/code>.<\/li>\n<\/ul>\n<h4 id=\"examples\">Examples<\/h4>\n<p>Each example includes the RPN input, the translated infix expression,\nand the evaluated output.<\/p>\n<p><strong>Tip<\/strong>: Copy any example and paste it into the input\nbox to test it!<\/p>\n<table style=\"width:100%;\">\n<colgroup>\n<col style=\"width: 43%\" />\n<col style=\"width: 34%\" />\n<col style=\"width: 21%\" />\n<\/colgroup>\n<thead>\n<tr>\n<th>RPN<\/th>\n<th><strong>Infix Notation<\/strong><\/th>\n<th><strong>Output (Stack)<\/strong><\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td><code>2 3 + 4 -<\/code> <\/td>\n<td><code>2 + 3 - 4<\/code> <\/td>\n<td><code>1<\/code><\/td>\n<\/tr>\n<tr>\n<td><code>1 2 3 - - ~<\/code> <\/td>\n<td><code>-(1 - (2 - 3))<\/code> <\/td>\n<td><code>-2<\/code><\/td>\n<\/tr>\n<tr>\n<td><code>27 1 3 / ^<\/code> <\/td>\n<td><code>27^(1/3)<\/code> <\/td>\n<td><code>3<\/code><\/td>\n<\/tr>\n<tr>\n<td><code>4 1 - 2 ^ 8 4 - 2 ^ + sqrt<\/code> <\/td>\n<td><code>sqrt((4 - 1)^2 + (8 - 4)^2)<\/code> <\/td>\n<td><code>5<\/code><\/td>\n<\/tr>\n<tr>\n<td><code>-b b 2 ^ 4 a c * * - sqrt + 2 a * /<\/code> <\/td>\n<td><code>(-b + sqrt(b^2-4ac))/(2a)<\/code> <\/td>\n<td><code>NA<\/code><\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<hr />\n<p>Created by Jesse C. Chen (<a\nhref=\"https://jessekelighine.com\">jessekelighine.com<\/a>) <br> <br><\/p>\n","type":"text"},{"name":"www/body.md","content":"\n---\n\n#### Usage\n\nEnter an expression in Reverse Polish Notation (RPN) to see its result and corresponding infix notation.\n\n**Note**: Make sure to separate each operand and operator with a space. Scroll down for usage examples.\n\n#### Available Operators\n\n- `+`    **ADD**:         *add* the last two numbers on stack.\n- `-`    **SUBTRACT**:    *subtract* the last two numbers on stack.\n- `*`    **MULTIPLY**:    *multiply* the last two numbers on stack.\n- `/`    **DIVIDE**:      *divide* the last two numbers on stack.\n- `^`    **POWER**:       raise the second-to-last number to the *power* of the last number on stack.\n- `!`    **FACTORIAL**:   calculate the *factorial* of the last number on stack.\n- `~`    **NEGATE**:      *negate* the last number on stack.\n- `sqrt` **SQUARE ROOT**: calculate the *square root* of the last number on stack.\n- `|`    **SWAP**:        *swap* the positions of the last two number on stack.\n\n#### Available Operands\n\n- You can use numbers or letters as *variables* (`a` to `z` and `A` to `Z`).\n- If *variables* are used,\n  the output will show a symbolic infix expression,\n  and the numeric result will be marked as `NA`.\n\n#### Examples\n\nEach example includes the RPN input, the translated infix expression, and the evaluated output.\n\n**Tip**: Copy any example and paste it into the input box to test it!\n\n| RPN                                    | **Infix Notation**             | **Output (Stack)** |\n|----------------------------------------|--------------------------------|--------------------|\n| `2 3 + 4 -`                            | `2 + 3 - 4`                    | `1`                |\n| `1 2 3 - - ~`                          | `-(1 - (2 - 3))`               | `-2`               |\n| `27 1 3 / ^`                           | `27^(1/3)`                     | `3`                |\n| `4 1 - 2 ^ 8 4 - 2 ^ + sqrt`           | `sqrt((4 - 1)^2 + (8 - 4)^2)`  | `5`                |\n| `-b b 2 ^ 4 a c * * - sqrt + 2 a * /`  | `(-b + sqrt(b^2-4ac))/(2a)`    | `NA`               |\n\n---\n\nCreated by Jesse C. Chen ([jessekelighine.com](https://jessekelighine.com))\n<br>\n<br>\n","type":"text"},{"name":"www/style.css","content":"/* TABLE */\n\ntable {\n\tmargin: 0 auto;\n\tpadding: 10px;\n    border-collapse: collapse;\n}\n\ntr {\n    border-bottom: 1px solid #666666;\n}\n\ntr:nth-child(even) {\n\tbackground-color: #fdfdfd;\n}\n\ntd {\n\tpadding: 10px;\n}\n\nth {\n\ttext-align: left;\n\tbackground-color: #fbfbfb;\n\tpadding: 15px;\n\tborder-top: 2px solid #666666;\n\tborder-bottom: 2px solid #666666;\n}\n","type":"text"}]
