[{"name":"app.R","content":"#!/usr/bin/env Rscript\n\n###############################################################################\n# -*- encoding: UTF-8 -*-                                                     #\n# Author: Jesse C. Chen (website: jessekelighine.com)                         #\n# Description: Reverse Polish Notation                                        #\n#                                                                             #\n# Last Modified: 2023-12-14                                                   #\n###############################################################################\nlibrary(shiny)\nlibrary(methods)\n###############################################################################\n\n### Stack Object ##############################################################\n\nStack <- setRefClass(\"Stack\", fields=list(values=\"vector\",length=\"numeric\"))\nStack$methods(initialize = function () length <<- 0)\nStack$methods(push = function ( item ) {\n                values <<- c(values, item)\n                length <<- length + length(item)\n                return(values[length]) })\nStack$methods(pop = function ( n=1 ) {\n                if ( length == 0 | length < n ) return(NULL)\n                item    <- values[(length-n+1):length]\n                length <<- length - n\n                values <<- if ( length==0 ) vector() else values[1:length]\n                return(item) })\n\n### Helper Functions ##########################################################\n\nparse         <- list()\nparse$split   <- function ( command ) strsplit(command,split=\" +\")[[1]]\nparse$optr    <- c(\"+\"=2,\"-\"=2,\"*\"=2,\"/\"=2,\"^\"=2,\"sqrt\"=1,\"~\"=1,\"!\"=1,\"%\"=1,\"&\"=2,\"=\"=1,\"abs\"=1)\nparse$opnd    <- \"^([-]{0,1}([0-9]*\\\\.){0,1}[0-9]+|[a-zA-Z])$\"\nparse$is.optr <- function ( item ) item %in% names(parse$optr)\nparse$is.opnd <- function ( item ) item |> grepl(pattern=parse$opnd, x=_)\nparse$eval    <- function ( opnds, optr ) {\n  if ( optr==\"+\"    ) output <- as.numeric(opnds[1]) + as.numeric(opnds[2])\n  if ( optr==\"-\"    ) output <- as.numeric(opnds[1]) - as.numeric(opnds[2])\n  if ( optr==\"*\"    ) output <- as.numeric(opnds[1]) * as.numeric(opnds[2])\n  if ( optr==\"/\"    ) output <- as.numeric(opnds[1]) / as.numeric(opnds[2])\n  if ( optr==\"^\"    ) output <- as.numeric(opnds[1]) ^ as.numeric(opnds[2])\n  if ( optr==\"sqrt\" ) output <- sqrt(as.numeric(opnds))\n  if ( optr==\"abs\"  ) output <- abs(as.numeric(opnds))\n  if ( optr==\"~\"    ) output <- -as.numeric(opnds)\n  if ( optr==\"!\"    ) output <- factorial(as.numeric(opnds))\n  if ( optr==\"%\"    ) output <- 1 / as.numeric(opnds)\n  if ( optr==\"&\"    ) output <- c( as.numeric(opnds[2]), as.numeric(opnds[1]) )\n  if ( optr==\"=\" ) return(NULL)\n  as.character(output)\n}\n\n### Main Function #############################################################\n\nto.infix <- function ( command ) {\n  stack.out <- Stack()\n  stack.opt <- Stack()\n  for ( item in parse$split(command) ) {\n    if ( parse$is.opnd(item) ) {\n      stack.out$push(item)\n      if ( grepl(\"^[a-zA-Z]$\",item) ) stack.opt$push(\"a\") else stack.opt$push(\"1\")\n      next\n    }\n    if ( parse$is.optr(item) ) {\n      n.opnd <- parse$optr[item]\n      if ( stack.out$length < n.opnd ) return(paste(\"ERROR: Not enough operands for\", paste0('\"',item,'\"')))\n      out <- stack.out$pop(n.opnd)\n      opt <- stack.opt$pop(n.opnd)\n      if ( item==\"=\" ) next\n      if ( item==\"&\" ) {\n        out <- out[2:1]\n        opt <- opt[2:1]\n      } else if ( item==\"%\" ) {\n        out <- paste(\"\\\\frac1{\",out,\"}\")\n        opt <- item\n      } else if ( item==\"!\" ) {\n        out <- if ( opt %in% c(\"1\",\"a\") ) paste0(out,\"!\") else paste0(\"\\\\left(\",out,\"\\\\right)!\")\n        opt <- item\n      } else if ( item==\"~\" ) {\n        out <- if ( opt %in% c(\"1\",\"a\",\"sqrt\",\"^\") ) paste0(\"-\",out) else paste0(\"-\\\\left(\",out,\"\\\\right)\")\n        opt <- item\n      } else if ( item==\"abs\" ) {\n        out <- paste0(\"\\\\left|\",out,\"\\\\right|\")\n        opt <- item\n      } else if ( item==\"sqrt\" ) {\n        out <- paste0(\"\\\\sqrt{\",out,\"}\")\n        opt <- item\n      } else if ( item==\"^\" ) {\n        if ( ! opt[1] %in% c(\"1\",\"a\",\"sqrt\") ) out[1] <- paste0(\"\\\\left(\",out[1],\"\\\\right)\")\n        out <- paste0(out[1],\"^{\",out[2],\"}\")\n        opt <- item\n      } else if ( item==\"/\" ) {\n        out <- paste(\"\\\\frac{\",out[1],\"}{\",out[2],\"}\")\n        opt <- item\n      } else if ( item==\"*\" ) {\n        if ( opt[1] %in% c(\"+\",\"-\") ) out[1] <- paste0(\"\\\\left(\",out[1],\"\\\\right)\")\n        if ( opt[2] %in% c(\"+\",\"-\") ) out[2] <- paste0(\"\\\\left(\",out[2],\"\\\\right)\")\n        out <- paste(out[1],ifelse(opt[1]==\"1\" & opt[2]==\"1\",\"\\\\cdot\",\"\"),out[2])\n        opt <- item\n      } else if ( item==\"+\" ) {\n        if ( opt[2]==1 & out[2]<0 ) out[2] <- paste0(\"\\\\left(\",out[2],\"\\\\right)\")\n        out <- paste(out[1],\"+\",out[2])\n        opt <- item\n      } else if ( item==\"-\" ) {\n        if ( ! opt[2] %in% c(\"1\",\"a\",\"!\",\"sqrt\",\"^\",\"*\") ) out[2] <- paste0(\"\\\\left(\",out[2],\"\\\\right)\")\n        out <- paste(out[1],\"-\",out[2])\n        opt <- item\n      } else { return(\"ERROR: ???\") }\n      stack.out$push(out)\n      stack.opt$push(opt)\n    } else { return(paste(\"ERROR: Input\", paste0('\"',item,'\"'), \"is not a legal command\")) }\n  }\n  return(stack.out$values)\n}\n\nevaluate <- function ( command ) {\n stack <- Stack()\n  for ( item in parse$split(command) ) {\n    if ( parse$is.opnd(item) ) { stack$push(item); next }\n    if ( parse$is.optr(item) ) {\n      n.opnd <- parse$optr[item]\n      if ( stack$length < n.opnd ) return(paste(\"ERROR: Not enough operands for\", paste0('\"',item,'\"')))\n      output <- stack$pop(n.opnd)\n      output <- parse$eval(opnds=output, optr=item)\n      stack$push(output)\n      next\n    }\n    return(paste(\"ERROR: Input\", paste0('\"',item,'\"'), \"is not a legal command\"))\n  }\n  return(stack$values)\n}\n\n### Shiny #####################################################################\n\nstyle.sheet <- \"width: auto;\nmax-width: 50em;\nmargin: 0 auto;\npadding: 10px 20px;\nfont-family: monospace;\nfont-size: 10pt;\nfont-weight: 500;\"\n\nui <- fluidPage(verticalLayout(div(style=style.sheet,\n                                   h3(strong(\"RPN Calculator\")),br(),\n                                   textInput(inputId=\"command\", label=\"Input Command\"),\n                                   strong(\"Output (Stack):\"), textOutput(\"stack\"),\n                                   strong(\"Infix Notation:\"), uiOutput(\"infix\"),\n                                   HTML(readLines(\"operators.html\")))))\n\nserver <- function ( input, output ) {\n  output$stack <- renderText({ paste(evaluate(input$command),collapse=\", \") |> ( \\ (x) if (x==\"\") \"\\u200B\" else x )() })\n  output$infix <- renderUI({\n      paste(to.infix(input$command),collapse=\", \") |> \n      ( \\ (y) if ( y == \"\" ) \"\\u200B\" else if ( grepl(\"ERROR\",y) ) y else paste0(\"$$\",y,\"$$\") )() |> \n      withMathJax()\n  })\n}\n\nshinyApp(ui=ui, server=server)\n","type":"text"},{"name":"Makefile","content":".PHONY: all clean\n\nall: operators.html\n\noperators.html: operators.md\n\t# pandoc operators.md --mathjax -o operators.html\n\tpandoc operators.md -o operators.html\n\nclean: \n\trm -rf *.html\n","type":"text"},{"name":"operators.html","content":"<hr />\n<h4 id=\"usage\">Usage<\/h4>\n<p>Input a command in reverse-polish notation (RPN) and see the output\nand infix notation representation!<\/p>\n<p><strong>Note<\/strong>: Separate the operators/operands with spaces.\nYou can find examples at the end of this page.<\/p>\n<h4 id=\"available-operators\">Available Operators<\/h4>\n<ul>\n<li><code>+<\/code> <strong>ADD<\/strong>: <em>add<\/em> the last two\nnumbers on stack.<\/li>\n<li><code>-<\/code> <strong>SUBTRACT<\/strong>: <em>subtract<\/em> the last\ntwo numbers on stack.<\/li>\n<li><code>*<\/code> <strong>MULTIPLY<\/strong>: <em>multiply<\/em> the last\ntwo numbers on stack.<\/li>\n<li><code>/<\/code> <strong>DIVIDE<\/strong>: <em>divide<\/em> the last two\nnumbers of stack.<\/li>\n<li><code>^<\/code> <strong>POWER<\/strong>: raise the second-to-last\nnumber to the <em>power<\/em> of the last number on stack.<\/li>\n<li><code>~<\/code> <strong>NEGATE<\/strong>: shorthand for\n<code>-1 *<\/code>, i.e., <em>negate<\/em> the last number on stack.<\/li>\n<li><code>!<\/code> <strong>FACTORIAL<\/strong>: calculate the\n<em>factorial<\/em> of the last number on stack.<\/li>\n<li><code>%<\/code> <strong>RECIPROCAL<\/strong>: shorthand for\n<code>1 &amp; /<\/code>, i.e., calculate the <em>reciprocal<\/em> of the\nlast number on stack.<\/li>\n<li><code>sqrt<\/code> <strong>SQUARE ROOT<\/strong>: calculate the\n<em>square root<\/em> of the last number on stack.<\/li>\n<li><code>abs<\/code> <strong>ABSOLUTE<\/strong>: calculate the\n<em>absolute value<\/em> the last number on stack.<\/li>\n<li><code>&amp;<\/code> <strong>SWAP<\/strong>: <em>swap<\/em> the\npositions of the last two number on stack.<\/li>\n<li><code>=<\/code> <strong>POP<\/strong>: <em>pop<\/em> or remove the last\nnumber on stack.<\/li>\n<\/ul>\n<h4 id=\"examples\">Examples<\/h4>\n<p>The following are some examples: first in RPN, then in infix\nnotation, then the output.<\/p>\n<p><strong>Tip<\/strong>: Copy the RPN in the input and verify that the\noutput is correct!<\/p>\n<table>\n<colgroup>\n<col style=\"width: 43%\" />\n<col style=\"width: 44%\" />\n<col style=\"width: 12%\" />\n<\/colgroup>\n<thead>\n<tr class=\"header\">\n<th>RPN<\/th>\n<th>infix<\/th>\n<th>output<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>2 0.5 ^<\/code>  <\/td>\n<td><code>2^0.5<\/code>  <\/td>\n<td><code>1.414<\/code><\/td>\n<\/tr>\n<tr class=\"even\">\n<td><code>2 3 + 4 -<\/code>  <\/td>\n<td><code>2 + 3 - 4<\/code>  <\/td>\n<td><code>1<\/code><\/td>\n<\/tr>\n<tr class=\"odd\">\n<td><code>1 2 + 3 ^ ~<\/code>  <\/td>\n<td><code>-((1 + 2)^3)<\/code>  <\/td>\n<td><code>-27<\/code><\/td>\n<\/tr>\n<tr class=\"even\">\n<td><code>4 1 - 2 ^ 8 4 - 2 ^ + sqrt<\/code> <\/td>\n<td><code>sqrt((4 - 1)^2 + (8 - 4)^2)<\/code> <\/td>\n<td><code>5<\/code><\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<hr />\n<p>Author: Jesse C. Chen (<a\nhref=\"https://jessekelighine.com\">jessekelighine.com<\/a>) <br> <br><\/p>\n","type":"text"},{"name":"operators.md","content":"\n---\n\n#### Usage\n\nInput a command in reverse-polish notation (RPN) and see the output and infix notation representation!\n\n**Note**: Separate the operators/operands with spaces. You can find examples at the end of this page. \n\n#### Available Operators\n\n- `+`    **ADD**:         *add* the last two numbers on stack.\n- `-`    **SUBTRACT**:    *subtract* the last two numbers on stack.\n- `*`    **MULTIPLY**:    *multiply* the last two numbers on stack.\n- `/`    **DIVIDE**:      *divide* the last two numbers of stack.\n- `^`    **POWER**:       raise the second-to-last number to the *power* of the last number on stack.\n- `~`    **NEGATE**:      shorthand for `-1 *`, i.e., *negate* the last number on stack.\n- `!`    **FACTORIAL**:   calculate the *factorial* of the last number on stack.\n- `%`    **RECIPROCAL**:  shorthand for `1 & /`, i.e., calculate the *reciprocal* of the last number on stack.\n- `sqrt` **SQUARE ROOT**: calculate the *square root* of the last number on stack.\n- `abs`  **ABSOLUTE**:    calculate the *absolute value* the last number on stack.\n- `&`    **SWAP**:        *swap* the positions of the last two number on stack.\n- `=`    **POP**:         *pop* or remove the last number on stack.\n\n#### Examples\n\nThe following are some examples:\nfirst in RPN,\nthen in infix notation,\nthen the output.\n\n**Tip**: Copy the RPN in the input and verify that the output is correct!\n\n| RPN                           | infix                          | output  |\n|-------------------------------|--------------------------------|---------|\n| `2 0.5 ^`                     | `2^0.5`                        | `1.414` |\n| `2 3 + 4 -`                   | `2 + 3 - 4`                    | `1`     |\n| `1 2 + 3 ^ ~`                 | `-((1 + 2)^3)`                 | `-27`   |\n| `4 1 - 2 ^ 8 4 - 2 ^ + sqrt`  | `sqrt((4 - 1)^2 + (8 - 4)^2)`  | `5`     |\n\n---\n\nAuthor: Jesse C. Chen ([jessekelighine.com](https://jessekelighine.com))\n<br>\n<br>\n","type":"text"}]
