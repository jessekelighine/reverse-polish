[{"name":"app.R","content":"#!/usr/bin/env Rscript\n\n###############################################################################\n# -*- encoding: UTF-8 -*-                                                     #\n# Author: Jesse C. Chen (website: jessekelighine.com)                         #\n# Description: Reverse Polish Notation                                        #\n#                                                                             #\n# Last Modified: 2023-12-14                                                   #\n###############################################################################\nlibrary(shiny)\n###############################################################################\n\nparse         <- list()\nparse$split   <- function ( command ) strsplit(command,split=\" +\")[[1]]\nparse$optr    <- c(\"+\"=2,\"-\"=2,\"*\"=2,\"/\"=2,\"^\"=2,\"v\"=1,\"~\"=1,\"|\"=2,\"!\"=1,\"=\"=1)\nparse$opnd    <- \"^[-]{0,1}([0-9]*\\\\.){0,1}[0-9]+$\"\nparse$is.optr <- function ( item ) item %in% names(parse$optr)\nparse$is.opnd <- function ( item ) item |> grepl(pattern=parse$opnd, x=_)\n\nparse$eval    <- function ( opnds, optr ) {\n  if ( optr==\"+\" ) output <- as.numeric(opnds[1]) + as.numeric(opnds[2])\n  if ( optr==\"-\" ) output <- as.numeric(opnds[1]) - as.numeric(opnds[2])\n  if ( optr==\"*\" ) output <- as.numeric(opnds[1]) * as.numeric(opnds[2])\n  if ( optr==\"/\" ) output <- as.numeric(opnds[1]) / as.numeric(opnds[2])\n  if ( optr==\"^\" ) output <- as.numeric(opnds[1]) ^ as.numeric(opnds[2])\n  if ( optr==\"v\" ) output <- sqrt(as.numeric(opnds))\n  if ( optr==\"~\" ) output <- -as.numeric(opnds)\n  if ( optr==\"!\" ) output <- factorial(as.numeric(opnds))\n  if ( optr==\"|\" ) output <- c( as.numeric(opnds[2]), as.numeric(opnds[1]) )\n  if ( optr==\"=\" ) output <- NULL\n  as.character(output)\n}\n\nparse$infix   <- function ( opnds, optr ) {\n  if ( optr==\"+\" ) output <- paste(\"(\", opnds[1], \"+\", opnds[2], \")\", sep=\" \")\n  if ( optr==\"-\" ) output <- paste(\"(\", opnds[1], \"-\", opnds[2], \")\", sep=\" \")\n  if ( optr==\"*\" ) output <- paste(\"(\", opnds[1], \"*\", opnds[2], \")\", sep=\" \")\n  if ( optr==\"/\" ) output <- paste(\"(\", opnds[1], \"/\", opnds[2], \")\", sep=\" \")\n  if ( optr==\"^\" ) output <- paste(\"(\", opnds[1], \"^\", opnds[2], \")\", sep=\" \")\n  if ( optr==\"v\" ) output <- paste(\"sqrt( \", opnds, \" )\", sep=\"\")\n  if ( optr==\"~\" ) output <- paste0(\"( -\",opnds,\" )\")\n  if ( optr==\"!\" ) output <- paste0(\"( \",opnds,\"! )\")\n  if ( optr==\"|\" ) output <- c( opnds[2], opnds[1] )\n  if ( optr==\"=\" ) output <- NULL\n  output\n}\n\n###############################################################################\n\nproto <- function ( command, fun=parse$eval ) {\n  stack <- c()\n  for ( item in parse$split(command) ) {\n    if ( parse$is.opnd(item) ) { stack <- c(stack, item); next }\n    if ( parse$is.optr(item) ) {\n      n.opnd  <- parse$optr[item]\n      n.stack <- length(stack)\n      if ( !( n.stack >= n.opnd ) ) {\n        return(c(\"Not enough operands in stack for\", paste0('\"',item,'\"'), \" to operate.\"))\n      }\n      output <- fun(opnds=stack[(n.stack-n.opnd+1):n.stack],optr=item)\n      stack  <- if ( length(stack)==n.opnd ) c() else stack[1:(n.stack-n.opnd)]\n      stack  <- c(stack, output)\n      next\n    }\n    return(c(\"Input\", paste0('\"',item,'\"'), \"is not a legal command.\"))\n  }\n  return(stack)\n}\n\nevaluate <- function ( command ) proto(command, fun=parse$eval)\nto.infix <- function ( command ) proto(command, fun=parse$infix)\n\n###############################################################################\n\nstyle.sheet <- \"width: auto;\nmax-width: 45em;\nmargin: 0 auto;\npadding: 10px 20px;\nfont-family: monospace;\nfont-size: 10pt;\nfont-weight: 500;\"\n\nui <- fluidPage(verticalLayout(div(style=style.sheet,\n                                   h3(strong(\"RPN Calculator\")),br(),\n                                   textInput(inputId=\"command\", label=\"Input Command\"),\n                                   strong(\"Output (Stack):\"), textOutput(\"stack\"),\n                                   strong(\"Infix Notation:\"), textOutput(\"infix\"),\n                                   HTML(readLines(\"operators.html\")))))\n\nserver <- function ( input, output ) {\n  output$infix <- renderText({ paste(to.infix(input$command),collapse=\" \") |> ( \\ (x) if (x==\"\") \"\\u200B\" else x )() })\n  output$stack <- renderText({ paste(evaluate(input$command),collapse=\" \") |> ( \\ (x) if (x==\"\") \"\\u200B\" else x )() })\n}\n\nshinyApp(ui=ui, server=server)\n","type":"text"},{"name":"Makefile","content":".PHONY: all clean\n\nall: operators.html\n\noperators.html: operators.md\n\tpandoc operators.md -o operators.html\n\nclean: \n\trm -rf *.html\n","type":"text"},{"name":"operators.html","content":"<hr />\n<h4 id=\"usage\">Usage<\/h4>\n<p>Input a command in reverse-polish notation (RPN) and see the output\nand infix notation representation!<\/p>\n<p><strong>Note<\/strong>: Separate the operators/operands with spaces.\nYou can find examples at the end of this page.<\/p>\n<h4 id=\"available-operators\">Available Operators<\/h4>\n<ul>\n<li><code>+<\/code> <strong>ADD<\/strong>: <em>add<\/em> the last two\nnumbers on stack.<\/li>\n<li><code>-<\/code> <strong>SUBTRACT<\/strong>: <em>subtract<\/em> the last\ntwo numbers on stack.<\/li>\n<li><code>*<\/code> <strong>MULTIPLY<\/strong>: <em>multiply<\/em> the last\ntwo numbers on stack.<\/li>\n<li><code>/<\/code> <strong>DIVIDE<\/strong>: <em>divide<\/em> the last two\nnumbers of stack.<\/li>\n<li><code>^<\/code> <strong>POWER<\/strong>: raise the second-to-last\nnumber to the <em>power<\/em> of the last number on stack.<\/li>\n<li><code>v<\/code> <strong>SQUARE ROOT<\/strong>: calculate the\n<em>square root<\/em> of the last number on stack.<\/li>\n<li><code>~<\/code> <strong>NEGATE<\/strong>: shorthand for\n<code>-1 *<\/code>, i.e., <em>negate<\/em> the last number on stack.<\/li>\n<li><code>!<\/code> <strong>FACTORIAL<\/strong>: calculate the\n<em>factorial<\/em> of the last number on stack.<\/li>\n<li><code>|<\/code> <strong>SWAP<\/strong>: <em>swap<\/em> the positions of\nthe last two number on stack.<\/li>\n<li><code>=<\/code> <strong>POP<\/strong>: <em>pop<\/em> or remove the last\nnumber on stack.<\/li>\n<\/ul>\n<h4 id=\"examples\">Examples<\/h4>\n<p>The following are some examples: first in RPN, then in infix\nnotation, then the output.<\/p>\n<p><strong>Tip<\/strong>: Copy the RPN in the input and verify that the\noutput is correct!<\/p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>RPN<\/th>\n<th>infix<\/th>\n<th>output<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>2 0.5 ^<\/code>  <\/td>\n<td><code>2^0.5<\/code>  <\/td>\n<td><code>1.414<\/code><\/td>\n<\/tr>\n<tr class=\"even\">\n<td><code>2 3 + 4 -<\/code>  <\/td>\n<td><code>( 2 + 3 ) - 4<\/code>  <\/td>\n<td><code>1<\/code><\/td>\n<\/tr>\n<tr class=\"odd\">\n<td><code>1 2 + 3 ^ ~<\/code>  <\/td>\n<td><code>-( ( 1 + 2 ) ^ 3 )<\/code>  <\/td>\n<td><code>-27<\/code><\/td>\n<\/tr>\n<tr class=\"even\">\n<td><code>4 1 - 2 ^ 8 4 - 2 ^ + v<\/code> <\/td>\n<td><code>sqrt( (4-1)^2 + (8-4)^2 )<\/code> <\/td>\n<td><code>5<\/code><\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<hr />\n<p>Author: Jesse C. Chen (<a\nhref=\"https://jessekelighine.com\">jessekelighine.com<\/a>) <br> <br><\/p>\n","type":"text"},{"name":"operators.md","content":"\n---\n\n#### Usage\n\nInput a command in reverse-polish notation (RPN) and see the output and infix notation representation!\n\n**Note**: Separate the operators/operands with spaces. You can find examples at the end of this page. \n\n#### Available Operators\n\n- `+` **ADD**:         *add* the last two numbers on stack.\n- `-` **SUBTRACT**:    *subtract* the last two numbers on stack.\n- `*` **MULTIPLY**:    *multiply* the last two numbers on stack.\n- `/` **DIVIDE**:      *divide* the last two numbers of stack.\n- `^` **POWER**:       raise the second-to-last number to the *power* of the last number on stack.\n- `v` **SQUARE ROOT**: calculate the *square root* of the last number on stack.\n- `~` **NEGATE**:      shorthand for `-1 *`, i.e., *negate* the last number on stack.\n- `!` **FACTORIAL**:   calculate the *factorial* of the last number on stack.\n- `|` **SWAP**:        *swap* the positions of the last two number on stack.\n- `=` **POP**:         *pop* or remove the last number on stack.\n\n#### Examples\n\nThe following are some examples:\nfirst in RPN,\nthen in infix notation,\nthen the output.\n\n**Tip**: Copy the RPN in the input and verify that the output is correct!\n\n| RPN                        | infix                        | output  |\n|----------------------------|------------------------------|---------|\n| `2 0.5 ^`                  | `2^0.5`                      | `1.414` |\n| `2 3 + 4 -`                | `( 2 + 3 ) - 4`              | `1`     |\n| `1 2 + 3 ^ ~`              | `-( ( 1 + 2 ) ^ 3 )`         | `-27`   |\n| `4 1 - 2 ^ 8 4 - 2 ^ + v`  | `sqrt( (4-1)^2 + (8-4)^2 )`  | `5`     |\n\n---\n\nAuthor: Jesse C. Chen ([jessekelighine.com](https://jessekelighine.com))\n<br>\n<br>\n","type":"text"}]
