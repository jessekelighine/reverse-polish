[{"name":"app.R","content":"#!/usr/bin/env Rscript\n\n###############################################################################\n# -*- encoding: UTF-8 -*-                                                     #\n# Author: Jesse C. Chen (website: jessekelighine.com)                         #\n# Description: Reverse Polish Notation                                        #\n#                                                                             #\n# Last Modified: 2023-12-14                                                   #\n###############################################################################\nlibrary(shiny)\nlibrary(methods)\n###############################################################################\n\n### Stack Object ##############################################################\n\nStack <- setRefClass(\"Stack\", fields=list(values=\"vector\",length=\"numeric\"))\nStack$methods(initialize = function () length <<- 0)\nStack$methods(top = function () values[length])\nStack$methods(push = function ( item ) {\n                values <<- c(values, item)\n                length <<- length + length(item)\n                return(values[length]) })\nStack$methods(pop = function ( n=1 ) {\n                if ( length == 0 | length < n ) return(NULL)\n                item    <- values[(length-n+1):length]\n                length <<- length - n\n                values <<- if ( length==0 ) vector() else values[1:length]\n                return(item) })\n\n### Helper Functions ##########################################################\n\nparse         <- list()\nparse$split   <- function ( command ) strsplit(command,split=\" +\")[[1]]\nparse$optr    <- c(\"+\"=2,\"-\"=2,\"*\"=2,\"/\"=2,\"^\"=2,\"v\"=1,\"~\"=1,\"|\"=2,\"!\"=1,\"=\"=1)\nparse$opnd    <- \"^[-]{0,1}([0-9]*\\\\.){0,1}[0-9]+$\"\nparse$is.optr <- function ( item ) item %in% names(parse$optr)\nparse$is.opnd <- function ( item ) item |> grepl(pattern=parse$opnd, x=_)\nparse$eval    <- function ( opnds, optr ) {\n  if ( optr==\"+\" ) output <- as.numeric(opnds[1]) + as.numeric(opnds[2])\n  if ( optr==\"-\" ) output <- as.numeric(opnds[1]) - as.numeric(opnds[2])\n  if ( optr==\"*\" ) output <- as.numeric(opnds[1]) * as.numeric(opnds[2])\n  if ( optr==\"/\" ) output <- as.numeric(opnds[1]) / as.numeric(opnds[2])\n  if ( optr==\"^\" ) output <- as.numeric(opnds[1]) ^ as.numeric(opnds[2])\n  if ( optr==\"v\" ) output <- sqrt(as.numeric(opnds))\n  if ( optr==\"~\" ) output <- -as.numeric(opnds)\n  if ( optr==\"!\" ) output <- factorial(as.numeric(opnds))\n  if ( optr==\"|\" ) output <- c( as.numeric(opnds[2]), as.numeric(opnds[1]) )\n  if ( optr==\"=\" ) return(NULL)\n  as.character(output)\n}\n\n### Main Function #############################################################\n\nto.infix <- function ( command ) {\n  stack.out <- Stack()\n  stack.opt <- Stack()\n  for ( item in parse$split(command) ) {\n    if ( parse$is.opnd(item) ) {\n      stack.out$push(item)\n      stack.opt$push(\"1\")\n      next\n    }\n    if ( parse$is.optr(item) ) {\n      n.opnd <- parse$optr[item]\n      if ( stack.out$length < n.opnd ) return(paste(\"Not enough operands for\", paste0('\"',item,'\"')))\n      out <- stack.out$pop(n.opnd)\n      opt <- stack.opt$pop(n.opnd)\n      if ( item==\"=\" ) next\n      if ( item==\"|\" ) {\n        out <- out[2:1]\n        opt <- opt[2:1]\n      } else if ( item==\"!\" ) {\n        out <- if ( opt %in% c(\"1\",\"v\") ) paste0(out,\"!\") else paste0(\"(\",out,\")!\")\n        opt <- item\n      } else if ( item==\"~\" ) {\n        out <- if ( opt %in% c(\"1\",\"v\",\"^\") ) paste0(\"-\",out) else paste0(\"-(\",out,\")\")\n        opt <- item\n      } else if ( item==\"v\" ) {\n        out <- paste0(\"sqrt(\",out,\")\")\n        opt <- item\n      } else if ( item==\"^\" ) {\n        if ( ! opt[1] %in% c(\"1\",\"v\") ) out[1] <- paste0(\"(\",out[1],\")\")\n        if ( ! opt[2] %in% c(\"1\",\"v\") ) out[2] <- paste0(\"(\",out[2],\")\")\n        out <- paste0(out[1],\"^\",out[2])\n        opt <- item\n      } else if ( item==\"/\" ) {\n        if (   opt[1] %in% c(\"+\",\"-\")     ) out[1] <- paste0(\"(\",out[1],\")\")\n        if ( ! opt[2] %in% c(\"1\",\"!\",\"v\") ) out[2] <- paste0(\"(\",out[2],\")\")\n        out <- paste(out[1],\"/\",out[2])\n        opt <- item\n      } else if ( item==\"*\" ) {\n        if ( opt[1] %in% c(\"+\",\"-\") ) out[1] <- paste0(\"(\",out[1],\")\")\n        if ( opt[2] %in% c(\"+\",\"-\") ) out[2] <- paste0(\"(\",out[2],\")\")\n        out <- paste(out[1],\"*\",out[2])\n        opt <- item\n      } else if ( item==\"+\" ) {\n        if ( opt[2]==1 & out[2]<0 ) out[2] <- paste0(\"(\",out[2],\")\")\n        out <- paste(out[1],\"+\",out[2])\n        opt <- item\n      } else if ( item==\"-\" ) {\n        if ( ! opt[2] %in% c(\"1\",\"!\",\"v\",\"^\",\"*\") ) out[2] <- paste0(\"(\",out[2],\")\")\n        out <- paste(out[1],\"-\",out[2])\n        opt <- item\n      } else { return(\"???\") }\n      stack.out$push(out)\n      stack.opt$push(opt)\n    } else { return(paste(\"Input\", paste0('\"',item,'\"'), \"is not a legal command\")) }\n  }\n  return(stack.out$values)\n}\n\nevaluate <- function ( command ) {\n stack <- Stack()\n  for ( item in parse$split(command) ) {\n    if ( parse$is.opnd(item) ) { stack$push(item); next }\n    if ( parse$is.optr(item) ) {\n      n.opnd <- parse$optr[item]\n      if ( stack$length < n.opnd ) return(paste(\"Not enough operands for\", paste0('\"',item,'\"')))\n      output <- stack$pop(n.opnd)\n      output <- parse$eval(opnds=output, optr=item)\n      stack$push(output)\n      next\n    }\n    return(paste(\"Input\", paste0('\"',item,'\"'), \"is not a legal command\"))\n  }\n  return(stack$values)\n}\n\n### Shiny #####################################################################\n\nstyle.sheet <- \"width: auto;\nmax-width: 45em;\nmargin: 0 auto;\npadding: 10px 20px;\nfont-family: monospace;\nfont-size: 10pt;\nfont-weight: 500;\"\n\nui <- fluidPage(verticalLayout(div(style=style.sheet,\n                                   h3(strong(\"RPN Calculator\")),br(),\n                                   textInput(inputId=\"command\", label=\"Input Command\"),\n                                   strong(\"Output (Stack):\"), textOutput(\"stack\"),\n                                   strong(\"Infix Notation:\"), textOutput(\"infix\"),\n                                   HTML(readLines(\"operators.html\")))))\n\nserver <- function ( input, output ) {\n  output$infix <- renderText({ paste(to.infix(input$command),collapse=\", \") |> ( \\ (x) if (x==\"\") \"\\u200B\" else x )() })\n  output$stack <- renderText({ paste(evaluate(input$command),collapse=\", \") |> ( \\ (x) if (x==\"\") \"\\u200B\" else x )() })\n}\n\nshinyApp(ui=ui, server=server)\n","type":"text"},{"name":"Makefile","content":".PHONY: all clean\n\nall: operators.html\n\noperators.html: operators.md\n\tpandoc operators.md -o operators.html\n\nclean: \n\trm -rf *.html\n","type":"text"},{"name":"operators.html","content":"<hr />\n<h4 id=\"usage\">Usage<\/h4>\n<p>Input a command in reverse-polish notation (RPN) and see the output\nand infix notation representation!<\/p>\n<p><strong>Note<\/strong>: Separate the operators/operands with spaces.\nYou can find examples at the end of this page.<\/p>\n<h4 id=\"available-operators\">Available Operators<\/h4>\n<ul>\n<li><code>+<\/code> <strong>ADD<\/strong>: <em>add<\/em> the last two\nnumbers on stack.<\/li>\n<li><code>-<\/code> <strong>SUBTRACT<\/strong>: <em>subtract<\/em> the last\ntwo numbers on stack.<\/li>\n<li><code>*<\/code> <strong>MULTIPLY<\/strong>: <em>multiply<\/em> the last\ntwo numbers on stack.<\/li>\n<li><code>/<\/code> <strong>DIVIDE<\/strong>: <em>divide<\/em> the last two\nnumbers of stack.<\/li>\n<li><code>^<\/code> <strong>POWER<\/strong>: raise the second-to-last\nnumber to the <em>power<\/em> of the last number on stack.<\/li>\n<li><code>v<\/code> <strong>SQUARE ROOT<\/strong>: calculate the\n<em>square root<\/em> of the last number on stack.<\/li>\n<li><code>~<\/code> <strong>NEGATE<\/strong>: shorthand for\n<code>-1 *<\/code>, i.e., <em>negate<\/em> the last number on stack.<\/li>\n<li><code>!<\/code> <strong>FACTORIAL<\/strong>: calculate the\n<em>factorial<\/em> of the last number on stack.<\/li>\n<li><code>|<\/code> <strong>SWAP<\/strong>: <em>swap<\/em> the positions of\nthe last two number on stack.<\/li>\n<li><code>=<\/code> <strong>POP<\/strong>: <em>pop<\/em> or remove the last\nnumber on stack.<\/li>\n<\/ul>\n<h4 id=\"examples\">Examples<\/h4>\n<p>The following are some examples: first in RPN, then in infix\nnotation, then the output.<\/p>\n<p><strong>Tip<\/strong>: Copy the RPN in the input and verify that the\noutput is correct!<\/p>\n<table>\n<colgroup>\n<col style=\"width: 40%\" />\n<col style=\"width: 46%\" />\n<col style=\"width: 13%\" />\n<\/colgroup>\n<thead>\n<tr class=\"header\">\n<th>RPN<\/th>\n<th>infix<\/th>\n<th>output<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>2 0.5 ^<\/code>  <\/td>\n<td><code>2^0.5<\/code>  <\/td>\n<td><code>1.414<\/code><\/td>\n<\/tr>\n<tr class=\"even\">\n<td><code>2 3 + 4 -<\/code>  <\/td>\n<td><code>2 + 3 - 4<\/code>  <\/td>\n<td><code>1<\/code><\/td>\n<\/tr>\n<tr class=\"odd\">\n<td><code>1 2 + 3 ^ ~<\/code>  <\/td>\n<td><code>-((1 + 2)^3)<\/code>  <\/td>\n<td><code>-27<\/code><\/td>\n<\/tr>\n<tr class=\"even\">\n<td><code>4 1 - 2 ^ 8 4 - 2 ^ + v<\/code> <\/td>\n<td><code>sqrt((4 - 1)^2 + (8 - 4)^2)<\/code> <\/td>\n<td><code>5<\/code><\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<hr />\n<p>Author: Jesse C. Chen (<a\nhref=\"https://jessekelighine.com\">jessekelighine.com<\/a>) <br> <br><\/p>\n","type":"text"},{"name":"operators.md","content":"\n---\n\n#### Usage\n\nInput a command in reverse-polish notation (RPN) and see the output and infix notation representation!\n\n**Note**: Separate the operators/operands with spaces. You can find examples at the end of this page. \n\n#### Available Operators\n\n- `+` **ADD**:         *add* the last two numbers on stack.\n- `-` **SUBTRACT**:    *subtract* the last two numbers on stack.\n- `*` **MULTIPLY**:    *multiply* the last two numbers on stack.\n- `/` **DIVIDE**:      *divide* the last two numbers of stack.\n- `^` **POWER**:       raise the second-to-last number to the *power* of the last number on stack.\n- `v` **SQUARE ROOT**: calculate the *square root* of the last number on stack.\n- `~` **NEGATE**:      shorthand for `-1 *`, i.e., *negate* the last number on stack.\n- `!` **FACTORIAL**:   calculate the *factorial* of the last number on stack.\n- `|` **SWAP**:        *swap* the positions of the last two number on stack.\n- `=` **POP**:         *pop* or remove the last number on stack.\n\n#### Examples\n\nThe following are some examples:\nfirst in RPN,\nthen in infix notation,\nthen the output.\n\n**Tip**: Copy the RPN in the input and verify that the output is correct!\n\n| RPN                        | infix                          | output  |\n|----------------------------|--------------------------------|---------|\n| `2 0.5 ^`                  | `2^0.5`                        | `1.414` |\n| `2 3 + 4 -`                | `2 + 3 - 4`                    | `1`     |\n| `1 2 + 3 ^ ~`              | `-((1 + 2)^3)`                 | `-27`   |\n| `4 1 - 2 ^ 8 4 - 2 ^ + v`  | `sqrt((4 - 1)^2 + (8 - 4)^2)`  | `5`     |\n\n---\n\nAuthor: Jesse C. Chen ([jessekelighine.com](https://jessekelighine.com))\n<br>\n<br>\n","type":"text"}]
