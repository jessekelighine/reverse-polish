[{"name":"app.R","content":"#!/usr/bin/env Rscript\n\n###############################################################################\n# -*- encoding: UTF-8 -*-                                                     #\n# Author: Jesse C. Chen (website: jessekelighine.com)                         #\n# Description: Reverse Polish Notation                                        #\n#                                                                             #\n# Last Modified: 2025-04-22                                                   #\n###############################################################################\noptions(scipen = 999999)\nlibrary(shiny)\nlibrary(fastmap)\n###############################################################################\n\noperator <- list()\nparse <- list()\n\n## Parsing ####################################################################\n\nparse$split <- function(command) strsplit(command, split = \" +\")[[1]]\n\nparse$is_negative <- function(str) substr(str, start = 1, stop = 1) == \"-\"\n\nparse$is_operator <- function(item) item %in% names(operator)\n\nparse$is_operand <- function(item) {\n  grepl(\n    pattern = \"^[-]{0,1}(([0-9]*\\\\.){0,1}[0-9]+|[a-zA-Z]|pi)$\",\n    x = item\n  )\n}\n\n## Operators ##################################################################\n\noperator[[\"+\"]] <- list()\noperator[[\"+\"]]$n <- 2\noperator[[\"+\"]]$eval <- function(operand) {\n  as.numeric(operand[1]) + as.numeric(operand[2])\n}\noperator[[\"+\"]]$infix <- function(operator, infix, operand) {\n  if (parse$is_negative(infix[2])) {\n    infix[2] <- paste0(\"\\\\left(\", infix[2], \"\\\\right)\")\n  }\n  list(infix = paste(infix[1], \"+\", infix[2]), operator = \"+\")\n}\n\noperator[[\"-\"]] <- list()\noperator[[\"-\"]]$n <- 2\noperator[[\"-\"]]$eval <- function(operand) {\n  as.numeric(operand[1]) - as.numeric(operand[2])\n}\noperator[[\"-\"]]$infix <- function(operator, infix, operand) {\n  if (parse$is_negative(infix[2]) || operator[2] %in% c(\"+\", \"-\")) {\n    infix[2] <- paste0(\"\\\\left(\", infix[2], \"\\\\right)\")\n  }\n  list(infix = paste(infix[1], \"-\", infix[2]), operator = \"-\")\n}\n\noperator[[\"*\"]] <- list()\noperator[[\"*\"]]$n <- 2\noperator[[\"*\"]]$eval <- function(operand) {\n  as.numeric(operand[1]) * as.numeric(operand[2])\n}\noperator[[\"*\"]]$infix <- function(operator, infix, operand) {\n  if (operator[1] %in% c(\"+\", \"-\")) {\n    infix[1] <- paste0(\"\\\\left(\", infix[1], \"\\\\right)\")\n  }\n  if (parse$is_negative(infix[2]) || operator[2] %in% c(\"+\", \"-\")) {\n    infix[2] <- paste0(\"\\\\left(\", infix[2], \"\\\\right)\")\n  }\n  list(infix = paste(infix[1], \"\\\\cdot\", infix[2]), operator = \"*\")\n}\n\noperator[[\"/\"]] <- list()\noperator[[\"/\"]]$n <- 2\noperator[[\"/\"]]$eval <- function(operand) {\n  as.numeric(operand[1]) / as.numeric(operand[2])\n}\noperator[[\"/\"]]$infix <- function(operator, infix, operand) {\n  list(\n    infix = paste(\"\\\\frac{\", infix[1], \"}{\", infix[2], \"}\"),\n    operator = \"/\"\n  )\n}\n\noperator[[\"\\\\\"]] <- list()\noperator[[\"\\\\\"]]$n <- 2\noperator[[\"\\\\\"]]$eval <- function(operand) {\n  as.numeric(operand[2]) / as.numeric(operand[1])\n}\noperator[[\"\\\\\"]]$infix <- function(operator, infix, operand) {\n  list(\n    infix = paste(\"\\\\frac{\", infix[2], \"}{\", infix[1], \"}\"),\n    operator = \"\\\\\"\n  )\n}\n\noperator[[\"^\"]] <- list()\noperator[[\"^\"]]$n <- 2\noperator[[\"^\"]]$eval <- function(operand) {\n  as.numeric(operand[1])^as.numeric(operand[2])\n}\noperator[[\"^\"]]$infix <- function(operator, infix, operand) {\n  if (parse$is_negative(infix[1]) || !parse$is_operand(infix[1])) {\n    infix[1] <- paste0(\"\\\\left(\", infix[1], \"\\\\right)\")\n  }\n  infix_output <- paste0(infix[1], \"^{\", infix[2], \"}\")\n  list(infix = infix_output, operator = \"^\")\n}\n\noperator[[\"!\"]] <- list()\noperator[[\"!\"]]$n <- 1\noperator[[\"!\"]]$eval <- function(operand) factorial(as.numeric(operand))\noperator[[\"!\"]]$infix <- function(operator, infix, operand) {\n  infix_output <- if (parse$is_negative(infix) || !parse$is_operand(operator)) {\n    paste0(\"\\\\left(\", infix, \"\\\\right)!\")\n  } else {\n    paste0(infix, \"!\")\n  }\n  list(infix = infix_output, operator = \"!\")\n}\n\noperator[[\"~\"]] <- list()\noperator[[\"~\"]]$n <- 1\noperator[[\"~\"]]$eval <- function(operand) -as.numeric(operand)\noperator[[\"~\"]]$infix <- function(operator, infix, operand) {\n  infix_output <- if (parse$is_negative(infix) || operator %in% c(\"+\", \"-\")) {\n    paste0(\"-\\\\left(\", infix, \"\\\\right)\")\n  } else {\n    paste0(\"-\", infix)\n  }\n  list(infix = infix_output, operator = \"~\")\n}\n\noperator[[\"sqrt\"]] <- list()\noperator[[\"sqrt\"]]$n <- 1\noperator[[\"sqrt\"]]$eval <- function(operand) sqrt(as.numeric(operand))\noperator[[\"sqrt\"]]$infix <- function(operator, infix, operand) {\n  infix_output <- paste0(\"\\\\sqrt{\", infix, \"}\")\n  list(infix = infix_output, operator = \"sqrt\")\n}\n\noperator[[\"abs\"]] <- list()\noperator[[\"abs\"]]$n <- 1\noperator[[\"abs\"]]$eval <- function(operand) abs(as.numeric(operand))\noperator[[\"abs\"]]$infix <- function(operator, infix, operand) {\n  infix_output <- paste0(\"\\\\left|\", infix, \"\\\\right|\")\n  list(infix = infix_output, operator = \"abs\")\n}\n\noperator[[\"log\"]] <- list()\noperator[[\"log\"]]$n <- 1\noperator[[\"log\"]]$eval <- function(operand) log(as.numeric(operand))\noperator[[\"log\"]]$infix <- function(operator, infix, operand) {\n  is_pos_operand <- !parse$is_negative(infix) && parse$is_operand(operator)\n  is_abs_or_sqrt <- operator %in% c(\"abs\", \"sqrt\")\n  if (is_pos_operand || is_abs_or_sqrt) {\n    infix_output <- paste0(\"\\\\log{\", infix, \"}\")\n  } else {\n    infix_output <- paste0(\"\\\\log\\\\left(\", infix[1], \"\\\\right)\")\n  }\n  list(infix = infix_output, operator = \"log\")\n}\n\noperator[[\"exp\"]] <- list()\noperator[[\"exp\"]]$n <- 1\noperator[[\"exp\"]]$eval <- function(operand) exp(as.numeric(operand))\noperator[[\"exp\"]]$infix <- function(operator, infix, operand) {\n  infix_output <- paste0(\"\\\\exp\\\\left(\", infix, \"\\\\right)\")\n  list(infix = infix_output, operator = \"exp\")\n}\n\noperator[[\"swap\"]] <- list()\noperator[[\"swap\"]]$n <- 2\noperator[[\"swap\"]]$eval <- function(operand) {\n  c(as.numeric(operand[2]), as.numeric(operand[1]))\n}\noperator[[\"swap\"]]$infix <- function(operator, infix, operand) {\n  list(infix = infix[2:1], operator = operator[2:1])\n}\n\noperator[[\"dup\"]] <- list()\noperator[[\"dup\"]]$n <- 1\noperator[[\"dup\"]]$eval <- function(operand) {\n  c(as.numeric(operand), as.numeric(operand))\n}\noperator[[\"dup\"]]$infix <- function(operator, infix, operand) {\n  list(infix = c(infix, infix), operator = c(operator, operator))\n}\n\noperator[[\"pop\"]] <- list()\noperator[[\"pop\"]]$n <- 1\noperator[[\"pop\"]]$eval <- function(operand) NULL\noperator[[\"pop\"]]$infix <- function(operator, infix, operand) NULL\n\n## Main Functions #############################################################\n\nmain <- function(command) {\n  command <- gsub(pattern = \"(^\\\\s+|\\\\s+$)\", replacement = \"\", x = command)\n  stack <- list()\n  stack$value <- faststack()\n  stack$infix <- faststack()\n  stack$operator <- faststack()\n  for (item in parse$split(command)) {\n    if (parse$is_operand(item)) {\n      stack$value$push((function(x) if (x == \"pi\") pi else x)(item))\n      stack$infix$push((function(x) if (x == \"pi\") \"\\\\pi\" else x)(item))\n      stack$operator$push(item)\n      next\n    }\n    if (parse$is_operator(item)) {\n      if (stack$value$size() < operator[[item]]$n) {\n        error_message <- paste(\n          \"ERROR: Not enough operands for\",\n          paste0('\"', item, '\"')\n        )\n        return(list(value = error_message, infix = error_message))\n      }\n      operators <- stack$operator$mpop(operator[[item]]$n) |> unlist() |> rev()\n      infix <- stack$infix$mpop(operator[[item]]$n) |> unlist() |> rev()\n      operand <- stack$value$mpop(operator[[item]]$n) |> unlist() |> rev()\n      output_infix <- operator[[item]]$infix(operators, infix, operand)\n      output_value <- operator[[item]]$eval(operand)\n      if (!is.null(output_value)) {\n        stack$value$mpush(.list = as.list(output_value))\n        stack$infix$mpush(.list = as.list(output_infix$infix))\n        stack$operator$mpush(.list = as.list(output_infix$operator))\n      }\n      next\n    }\n    error_message <- paste(\n      \"ERROR: \",\n      paste0('\"', item, '\"'),\n      \"is not a legal command\"\n    )\n    return(list(value = error_message, infix = error_message))\n  }\n  return(list(\n    value = stack$value$as_list() |> unlist(),\n    infix = stack$infix$as_list() |> unlist()\n  ))\n}\n\n## Shiny ######################################################################\n\nstyle_sheet <- paste(\n  \"width: auto;\",\n  \"max-width: 55em;\",\n  \"margin: 0 auto;\"\n)\n\nui <- fluidPage(\n  includeCSS(\"www/style.css\"),\n  verticalLayout(\n    div(\n      style = style_sheet,\n      withMathJax(),\n      h3(strong(\"Reverse Polish Notation Calculator\")),\n      shiny::HTML(\n        paste(\n          \"<p>\",\n          \"Created by Jesse C. Chen\",\n          paste0(\n            \"(\",\n            \"<a href='https://jessekelighine.com'>jessekelighine.com<\/a>\",\n            \")\"\n          ),\n          \"<\/p>\"\n        )\n      ),\n      br(),\n      textInput(inputId = \"command\", label = \"RPN Input\", width = \"55em\"),\n      uiOutput(\"result\"),\n      includeHTML(\"www/body.html\")\n    )\n  )\n)\n\nserver <- function(input, output) {\n  output$result <- renderUI({\n    result <- main(input$command) |> lapply(\\(x) paste(x, collapse = \", \"))\n    zero_width_space <- \"\\u200B\"\n    if (result$value == \"\") result$value <- zero_width_space\n    if (result$infix == \"\") {\n      result$infix <- zero_width_space\n    } else if (!grepl(\"ERROR\", result$infix)) {\n      result$infix <- paste0(\"\\\\[\", result$infix, \"\\\\]\")\n    }\n    withMathJax(\n      strong(\"Output (Stack):\"),\n      br(),\n      result$value,\n      br(),\n      strong(\"Infix Notation:\"),\n      br(),\n      result$infix\n    )\n  })\n}\n\nshinyApp(ui = ui, server = server)\n","type":"text"},{"name":"Makefile","content":".PHONY: all clean\n\nall: www/body.html\n\nwww/body.html: www/body.md www/style.css\n\tpandoc www/body.md \\\n\t\t--mathjax \\\n\t\t--output www/body.html\n\nclean:\n\trm -rf www/*.html\n","type":"text"},{"name":"www/body.html","content":"<hr />\n<h4 id=\"usage\">Usage<\/h4>\n<p>Enter an expression in Reverse Polish Notation (RPN) to see its\nresult and corresponding infix notation. Make sure to separate each\noperand and operator with a space. Scroll down for usage examples.<\/p>\n<p>🤔 <strong>Not familiar with RPN?<\/strong> Check out the <a\nhref=\"https://en.wikipedia.org/wiki/Reverse_Polish_notation\">Wikipedia\narticle<\/a> or watch the excellent explainer by <a\nhref=\"https://www.youtube.com/watch?v=7ha78yWRDlE\">Computerphile<\/a>.<\/p>\n<h4 id=\"available-operators\">Available Operators<\/h4>\n<p>There are two types of operators: <em>mathematical operators<\/em> and\n<em>stack operators<\/em>. Here are the <em>mathematical\noperators<\/em>:<\/p>\n<ul>\n<li><code>+<\/code> <strong>ADD<\/strong>: <em>add<\/em> the last two\nnumbers on stack.<\/li>\n<li><code>-<\/code> <strong>SUBTRACT<\/strong>: <em>subtract<\/em> the last\ntwo numbers on stack.<\/li>\n<li><code>*<\/code> <strong>MULTIPLY<\/strong>: <em>multiply<\/em> the last\ntwo numbers on stack.<\/li>\n<li><code>/<\/code> <strong>DIVIDE<\/strong>: <em>divide<\/em> the last two\nnumbers on stack.<\/li>\n<li><code>\\<\/code> <strong>DIVIDE<\/strong>: <em>divide<\/em> the last two\nnumbers on stack, but the other way around.<\/li>\n<li><code>^<\/code> <strong>POWER<\/strong>: raise the second-to-last\nnumber to the <em>power<\/em> of the last number on stack.<\/li>\n<li><code>!<\/code> <strong>FACTORIAL<\/strong>: calculate the\n<em>factorial<\/em> of the last number on stack.<\/li>\n<li><code>~<\/code> <strong>NEGATE<\/strong>: <em>negate<\/em> the last\nnumber on stack.<\/li>\n<li><code>abs<\/code> <strong>ABSOLUTE VALUE<\/strong>: calculate the\n<em>absolute value<\/em> of the last number on stack.<\/li>\n<li><code>log<\/code> <strong>LOGARITHM<\/strong>: calculate the\n<em>natural logarithm<\/em> of the last number on stack.<\/li>\n<li><code>exp<\/code> <strong>EXPONENTIAL<\/strong>: calculate the\n<em>exponential<\/em> of the last number on stack.<\/li>\n<li><code>sqrt<\/code> <strong>SQUARE ROOT<\/strong>: calculate the\n<em>square root<\/em> of the last number on stack.<\/li>\n<\/ul>\n<p>And here are the <em>stack operators<\/em> that manipulate the\nstack:<\/p>\n<ul>\n<li><code>pop<\/code> <strong>POP<\/strong>: <em>pop<\/em>/remove the last\nnumber off the stack.<\/li>\n<li><code>dup<\/code> <strong>DUPLICATE<\/strong>: <em>duplicate<\/em> the\nlast number on stack.<\/li>\n<li><code>swap<\/code> <strong>SWAP<\/strong>: <em>swap<\/em> the positions\nof the last two number on stack.<\/li>\n<\/ul>\n<h4 id=\"available-operands\">Available Operands<\/h4>\n<p>You can use numbers or letters <code>a<\/code> to <code>z<\/code> as\noperands. If letters are used, a symbolic infix expression will be\ncalculated, and the numeric output will be <code>NA<\/code>.<\/p>\n<h4 id=\"examples\">Examples<\/h4>\n<p>💡 <strong>Tip<\/strong>: Copy any example and paste it into the input\nbox to test it!<\/p>\n<table>\n<colgroup>\n<col style=\"width: 33%\" />\n<col style=\"width: 33%\" />\n<col style=\"width: 33%\" />\n<\/colgroup>\n<thead>\n<tr>\n<th>RPN Input<\/th>\n<th>Output (Stack)<\/th>\n<th>Infix Notation<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td><code>2 3 + 4 -<\/code><\/td>\n<td><code>1<\/code><\/td>\n<td><code>2 + 3 - 4<\/code><\/td>\n<\/tr>\n<tr>\n<td><code>1 2 3 - - ~<\/code><\/td>\n<td><code>-2<\/code><\/td>\n<td><code>-(1 - (2 - 3))<\/code><\/td>\n<\/tr>\n<tr>\n<td><code>27 1 3 / ^<\/code><\/td>\n<td><code>3<\/code><\/td>\n<td><code>27^(1/3)<\/code><\/td>\n<\/tr>\n<tr>\n<td><code>4 1 - 2 ^ 8 4 - 2 ^ + sqrt<\/code><\/td>\n<td><code>5<\/code><\/td>\n<td><code>sqrt((4 - 1)^2 + (8 - 4)^2)<\/code><\/td>\n<\/tr>\n<tr>\n<td><code>-b b 2 ^ 4 a c * * - sqrt + 2 a * /<\/code><\/td>\n<td><code>NA<\/code><\/td>\n<td><code>(-b + sqrt(b^2 - 4·a·c))/(2·a)<\/code><\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<p><br><\/p>\n","type":"text"},{"name":"www/body.md","content":"\n---\n\n#### Usage\n\nEnter an expression in Reverse Polish Notation (RPN) to see its result and corresponding infix notation.\nMake sure to separate each operand and operator with a space. Scroll down for usage examples.\n\n🤔 **Not familiar with RPN?**\nCheck out the [Wikipedia article](https://en.wikipedia.org/wiki/Reverse_Polish_notation)\nor watch the excellent explainer by [Computerphile](https://www.youtube.com/watch?v=7ha78yWRDlE).\n\n#### Available Operators\n\nThere are two types of operators: *mathematical operators* and *stack operators*.\nHere are the *mathematical operators*:\n\n- `+`    **ADD**:         *add* the last two numbers on stack.\n- `-`    **SUBTRACT**:    *subtract* the last two numbers on stack.\n- `*`    **MULTIPLY**:    *multiply* the last two numbers on stack.\n- `/`    **DIVIDE**:      *divide* the last two numbers on stack.\n- `\\`    **DIVIDE**:      *divide* the last two numbers on stack, but the other way around.\n- `^`    **POWER**:       raise the second-to-last number to the *power* of the last number on stack.\n- `!`    **FACTORIAL**:   calculate the *factorial* of the last number on stack.\n- `~`    **NEGATE**:      *negate* the last number on stack.\n- `abs`  **ABSOLUTE VALUE**: calculate the *absolute value* of the last number on stack.\n- `log`  **LOGARITHM**: calculate the *natural logarithm* of the last number on stack.\n- `exp`  **EXPONENTIAL**: calculate the *exponential* of the last number on stack.\n- `sqrt` **SQUARE ROOT**: calculate the *square root* of the last number on stack.\n\nAnd here are the *stack operators* that manipulate the stack:\n\n- `pop` **POP**: *pop*/remove the last number off the stack.\n- `dup` **DUPLICATE**: *duplicate* the last number on stack.\n- `swap` **SWAP**: *swap* the positions of the last two number on stack.\n\n#### Available Operands\n\nYou can use numbers or letters `a` to `z` as operands.\nIf letters are used,\na symbolic infix expression will be calculated,\nand the numeric output will be `NA`.\n\n#### Examples\n\n💡 **Tip**: Copy any example and paste it into the input box to test it!\n\n| RPN Input                             | Output (Stack)  | Infix Notation                   |\n| ----                                  | ----            | ----                             |\n| `2 3 + 4 -`                           | `1`             | `2 + 3 - 4`                      |\n| `1 2 3 - - ~`                         | `-2`            | `-(1 - (2 - 3))`                 |\n| `27 1 3 / ^`                          | `3`             | `27^(1/3)`                       |\n| `4 1 - 2 ^ 8 4 - 2 ^ + sqrt`          | `5`             | `sqrt((4 - 1)^2 + (8 - 4)^2)`    |\n| `-b b 2 ^ 4 a c * * - sqrt + 2 a * /` | `NA`            | `(-b + sqrt(b^2 - 4·a·c))/(2·a)` |\n\n<br>\n","type":"text"},{"name":"www/style.css","content":"/* style.css */\n\n@import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap');\n\nh4 {\n\tfont-weight: 600;\n}\n\nbody {\n\tfont-family: \"IBM Plex Mono\", monospace;\n}\n\ntable {\n\tmargin: 0 auto;\n\ttable-layout: auto;\n}\n\ntr {\n\tborder-bottom: 1px solid #666666;\n}\n\ntr:nth-child(even) {\n\tbackground-color: #fdfdfd;\n}\n\ntd {\n\tpadding: 10px;\n}\n\nth {\n\ttext-align: left;\n\tbackground-color: #fbfbfb;\n\tpadding: 10px;\n\tborder-top: 2px solid #666666;\n\tborder-bottom: 2px solid #666666;\n}\n","type":"text"}]
