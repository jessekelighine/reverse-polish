[{"name":"app.R","content":"#!/usr/bin/env Rscript\n\n###############################################################################\n# -*- encoding: UTF-8 -*-                                                     #\n# Author: Jesse C. Chen (website: jessekelighine.com)                         #\n# Description: Reverse Polish Notation                                        #\n#                                                                             #\n# Last Modified: 2023-12-17                                                   #\n###############################################################################\nlibrary(shiny)\n###############################################################################\n\n### Stack Object ##############################################################\n\nStack <- setRefClass(\"Stack\",\n                     fields  = list(values=\"vector\",length=\"numeric\"),\n                     methods = list(initialize = function () length <<- 0,\n                                    push = function ( item ) {\n                                      values <<- c(values, item)\n                                      length <<- length + length(item)\n                                      values[length]\n                                    },\n                                    pop = function ( n=1 ) {\n                                      if ( length == 0 | length < n ) return(NULL)\n                                      item    <- values[(length-n+1):length]\n                                      length <<- length - n\n                                      values <<- if ( length==0 ) vector() else values[1:length]\n                                      item }\n                     )\n)\n\n### Operators & Parsing #######################################################\n\noperator <- list()\nparse    <- list()\n\nparse$split   <- function ( command ) strsplit(command,split=\" +\")[[1]]\nparse$is.neg  <- function ( str  ) substr(str,start=1,stop=1)==\"-\"\nparse$is.optr <- function ( item ) item %in% names(operator)\nparse$is.opnd <- function ( item ) item |> grepl(pattern=\"^[-]{0,1}(([0-9]*\\\\.){0,1}[0-9]+|[a-zA-Z])$\", x=_)\nparse$is.symb <- function ( item ) item |> grepl(pattern=\"^[-]{0,1}[a-zA-Z]$\", x=_)\n\noperator[[\"+\"]]       <- list()\noperator[[\"+\"]]$n     <- 2\noperator[[\"+\"]]$eval  <- function ( opnds ) as.numeric(opnds[1]) + as.numeric(opnds[2])\noperator[[\"+\"]]$infix <- function ( opt, out ) {\n  if ( parse$is.neg(out[2]) ) out[2] <- paste0(\"\\\\left(\",out[2],\"\\\\right)\")\n  list(out=paste(out[1],\"+\",out[2]), opt=\"+\")\n}\n\noperator[[\"-\"]]       <- list()\noperator[[\"-\"]]$n     <- 2\noperator[[\"-\"]]$eval  <- function ( opnds ) as.numeric(opnds[1]) - as.numeric(opnds[2])\noperator[[\"-\"]]$infix <- function ( opt, out ) {\n  if ( parse$is.neg(out[2]) | opt[2] %in% c(\"+\",\"-\") ) out[2] <- paste0(\"\\\\left(\",out[2],\"\\\\right)\")\n  list(out=paste(out[1],\"-\",out[2]), opt=\"-\")\n}\n\noperator[[\"*\"]]       <- list()\noperator[[\"*\"]]$n     <- 2\noperator[[\"*\"]]$eval  <- function ( opnds ) as.numeric(opnds[1]) * as.numeric(opnds[2])\noperator[[\"*\"]]$infix <- function ( opt, out ) {\n  temp <- parse$is.neg(out[2])\n  if ( opt[1] %in% c(\"+\",\"-\") ) out[1] <- paste0(\"\\\\left(\",out[1],\"\\\\right)\")\n  if ( temp | opt[2] %in% c(\"+\",\"-\") ) out[2] <- paste0(\"\\\\left(\",out[2],\"\\\\right)\")\n  temp <- if ( opt[1]==\"1\" & opt[2]==\"a\" & !temp ) paste(out[1],out[2]) else paste(out[1],\"\\\\cdot\",out[2])\n  list(out=temp,opt=\"*\")\n}\n\noperator[[\"/\"]]       <- list()\noperator[[\"/\"]]$n     <- 2\noperator[[\"/\"]]$eval  <- function ( opnds ) as.numeric(opnds[1]) / as.numeric(opnds[2])\noperator[[\"/\"]]$infix <- function ( opt, out ) list(out=paste(\"\\\\frac{\",out[1],\"}{\",out[2],\"}\"), opt=\"/\")\n\noperator[[\"^\"]]       <- list()\noperator[[\"^\"]]$n     <- 2\noperator[[\"^\"]]$eval  <- function ( opnds ) as.numeric(opnds[1]) ^ as.numeric(opnds[2])\noperator[[\"^\"]]$infix <- function ( opt, out ) {\n  if ( parse$is.neg(out[1]) | ! parse$is.opnd(out[1]) ) out[1] <- paste0(\"\\\\left(\",out[1],\"\\\\right)\")\n  list(out=paste0(out[1],\"^{\",out[2],\"}\"), opt=\"^\")\n}\n\noperator[[\"!\"]]       <- list()\noperator[[\"!\"]]$n     <- 1\noperator[[\"!\"]]$eval  <- function ( opnds ) factorial(as.numeric(opnds))\noperator[[\"!\"]]$infix <- function ( opt, out ) {\n  temp <- if ( parse$is.neg(out) | ! parse$is.opnd(opt) ) paste0(\"\\\\left(\",out,\"\\\\right)!\") else paste0(out,\"!\")\n  list(out=temp, opt=\"!\")\n}\n\noperator[[\"sqrt\"]]       <- list()\noperator[[\"sqrt\"]]$n     <- 1\noperator[[\"sqrt\"]]$eval  <- function ( opnds ) sqrt(as.numeric(opnds))\noperator[[\"sqrt\"]]$infix <- function ( opt, out ) list(out=paste0(\"\\\\sqrt{\",out,\"}\"), opt=\"sqrt\")\n\noperator[[\"|\"]]       <- list()\noperator[[\"|\"]]$n     <- 2\noperator[[\"|\"]]$eval  <- function ( opnds ) c(as.numeric(opnds[2]), as.numeric(opnds[1]))\noperator[[\"|\"]]$infix <- function ( opt, out ) list(out=out[2:1], opt=opt[2:1])\n\noperator[[\"~\"]]       <- list()\noperator[[\"~\"]]$n     <- 1\noperator[[\"~\"]]$eval  <- function ( opnds ) -as.numeric(opnds)\noperator[[\"~\"]]$infix <- function ( opt, out ) {\n  temp.neg <- parse$is.neg(out)\n  out <- if ( parse$is.neg(out) | opt %in% c(\"+\",\"-\") ) paste0(\"-\\\\left(\",out,\"\\\\right)\") else paste0(\"-\",out)\n  list(out=out, opt=\"~\")\n}\n\n### Main Functions ############################################################\n\nmain <- function ( command ) {\n  command <- gsub(pattern=\"(^\\\\s+|\\\\s+$)\",replacement=\"\",x=command)\n  stack.val <- Stack()\n  stack.out <- Stack()\n  stack.opt <- Stack()\n  for ( item in parse$split(command) ) {\n    if ( parse$is.opnd(item) ) {\n      stack.val$push( item )\n      stack.out$push( item )\n      stack.opt$push( ifelse(parse$is.symb(item),\"a\",\"1\") )\n      next\n    } else if ( parse$is.optr(item) ) {\n      if ( stack.val$length < operator[[item]]$n ) {\n        mess <- paste(\"ERROR: Not enough operands for\", paste0('\"',item,'\"'))\n        return(list(val=mess,inf=mess))\n      }\n      opd <- stack.val$pop(operator[[item]]$n)\n      out <- stack.out$pop(operator[[item]]$n)\n      opt <- stack.opt$pop(operator[[item]]$n)\n      out.v <- operator[[item]]$eval(opd)\n      out.i <- operator[[item]]$infix(opt,out)\n      stack.val$push(out.v)\n      stack.out$push(out.i$out)\n      stack.opt$push(out.i$opt)\n      next\n    }\n    mess <- paste(\"ERROR: Input\", paste0('\"',item,'\"'), \"is not a legal command\")\n    return(list(val=mess,inf=mess))\n  }\n  return(list(val=stack.val$values, inf=stack.out$values))\n}\n\n### Shiny #####################################################################\n\nstyle.sheet <- \"width: auto; max-width: 55em; margin: 0 auto; font-family: monospace;\"\n\nui <- fluidPage(includeCSS(\"www/style.css\"),\n                verticalLayout(div(style=style.sheet, withMathJax(),\n                                   h3(strong(\"RPN Calculator\")),br(),\n                                   textInput(inputId=\"command\", label=\"Input Command\"),\n                                   uiOutput(\"result\"), includeHTML(\"www/body.html\")\n                                   )))\n\nserver <- function ( input, output ) {\n  output$result <- renderUI({\n    res <- main(input$command) |> lapply( \\ (x) paste(x,collapse=\", \") )\n    if ( res$val == \"\" ) res$val <- \"\\u200B\"\n    if ( res$inf == \"\" ) {\n      res$inf <- \"\\u200B\"\n    } else if ( !grepl(\"ERROR\",res$inf ) ) {\n      res$inf <- paste0(\"\\\\[\",res$inf,\"\\\\]\")\n    }\n    withMathJax(strong(\"Output (Stack):\"),br(),res$val,br(),\n                strong(\"Infix Notation:\"),br(),res$inf)\n  })\n}\n\nshinyApp(ui=ui, server=server)\n","type":"text"},{"name":"Makefile","content":".PHONY: all clean\n\nall: www/body.html\n\nwww/body.html: www/body.md\n\tpandoc www/body.md -o www/body.html\n\nclean: \n\trm -rf www/*.html\n","type":"text"},{"name":"www/body.html","content":"<hr />\n<h4 id=\"usage\">Usage<\/h4>\n<p>Input a command in reverse-polish notation (RPN) and see the output\nand infix notation representation!<\/p>\n<p><strong>Note<\/strong>: Separate the operators/operands with spaces.\nYou can find examples at the end of this page.<\/p>\n<h4 id=\"available-operators\">Available Operators<\/h4>\n<ul>\n<li><code>+<\/code> <strong>ADD<\/strong>: <em>add<\/em> the last two\nnumbers on stack.<\/li>\n<li><code>-<\/code> <strong>SUBTRACT<\/strong>: <em>subtract<\/em> the last\ntwo numbers on stack.<\/li>\n<li><code>*<\/code> <strong>MULTIPLY<\/strong>: <em>multiply<\/em> the last\ntwo numbers on stack.<\/li>\n<li><code>/<\/code> <strong>DIVIDE<\/strong>: <em>divide<\/em> the last two\nnumbers on stack.<\/li>\n<li><code>^<\/code> <strong>POWER<\/strong>: raise the second-to-last\nnumber to the <em>power<\/em> of the last number on stack.<\/li>\n<li><code>!<\/code> <strong>FACTORIAL<\/strong>: calculate the\n<em>factorial<\/em> of the last number on stack.<\/li>\n<li><code>~<\/code> <strong>NEGATE<\/strong>: <em>negate<\/em> the last\nnumber on stack.<\/li>\n<li><code>sqrt<\/code> <strong>SQUARE ROOT<\/strong>: calculate the\n<em>square root<\/em> of the last number on stack.<\/li>\n<li><code>|<\/code> <strong>SWAP<\/strong>: <em>swap<\/em> the positions of\nthe last two number on stack.<\/li>\n<\/ul>\n<h4 id=\"available-operands\">Available Operands<\/h4>\n<ul>\n<li>Apart from numbers, you can use the single alphabets, i.e.,\n<code>a<\/code> to <code>z<\/code>, as operands.<\/li>\n<li>If alphabets are used as operands, then a <em>symbolic<\/em>\n<strong>Infix Notation<\/strong> is calculated, and the <em>numeric<\/em>\n<strong>Output (Stack)<\/strong> will be <code>NA<\/code>.<\/li>\n<\/ul>\n<h4 id=\"examples\">Examples<\/h4>\n<p>The following are some examples: first in RPN, then in infix\nnotation, then the output.<\/p>\n<p><strong>Tip<\/strong>: Copy the RPN in the input and verify that the\noutput is correct!<\/p>\n<table style=\"width:100%;\">\n<colgroup>\n<col style=\"width: 43%\" />\n<col style=\"width: 34%\" />\n<col style=\"width: 21%\" />\n<\/colgroup>\n<thead>\n<tr class=\"header\">\n<th>RPN<\/th>\n<th><strong>Infix Notation<\/strong><\/th>\n<th><strong>Output (Stack)<\/strong><\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>2 3 + 4 -<\/code> <\/td>\n<td><code>2 + 3 - 4<\/code> <\/td>\n<td><code>1<\/code><\/td>\n<\/tr>\n<tr class=\"even\">\n<td><code>1 2 3 - - ~<\/code> <\/td>\n<td><code>-(1 - (2 - 3))<\/code> <\/td>\n<td><code>-2<\/code><\/td>\n<\/tr>\n<tr class=\"odd\">\n<td><code>27 1 3 / ^<\/code> <\/td>\n<td><code>27^(1/3)<\/code> <\/td>\n<td><code>3<\/code><\/td>\n<\/tr>\n<tr class=\"even\">\n<td><code>4 1 - 2 ^ 8 4 - 2 ^ + sqrt<\/code> <\/td>\n<td><code>sqrt((4 - 1)^2 + (8 - 4)^2)<\/code> <\/td>\n<td><code>5<\/code><\/td>\n<\/tr>\n<tr class=\"odd\">\n<td><code>-b b 2 ^ 4 a c * * - sqrt + 2 a * /<\/code> <\/td>\n<td><code>(-b + sqrt(b^2-4ac))/(2a)<\/code> <\/td>\n<td><code>NA<\/code><\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<hr />\n<p>Author: Jesse C. Chen (<a\nhref=\"https://jessekelighine.com\">jessekelighine.com<\/a>) <br> <br><\/p>\n","type":"text"},{"name":"www/body.md","content":"\n---\n\n#### Usage\n\nInput a command in reverse-polish notation (RPN) and see the output and infix notation representation!\n\n**Note**: Separate the operators/operands with spaces. You can find examples at the end of this page. \n\n#### Available Operators\n\n- `+`    **ADD**:         *add* the last two numbers on stack.\n- `-`    **SUBTRACT**:    *subtract* the last two numbers on stack.\n- `*`    **MULTIPLY**:    *multiply* the last two numbers on stack.\n- `/`    **DIVIDE**:      *divide* the last two numbers on stack.\n- `^`    **POWER**:       raise the second-to-last number to the *power* of the last number on stack.\n- `!`    **FACTORIAL**:   calculate the *factorial* of the last number on stack.\n- `~`    **NEGATE**:      *negate* the last number on stack.\n- `sqrt` **SQUARE ROOT**: calculate the *square root* of the last number on stack.\n- `|`    **SWAP**:        *swap* the positions of the last two number on stack.\n\n#### Available Operands\n\n- Apart from numbers, you can use the single alphabets, i.e., `a` to `z`, as operands.\n- If alphabets are used as operands, then a *symbolic* **Infix Notation** is calculated,\n  and the *numeric* **Output (Stack)** will be `NA`.\n\n#### Examples\n\nThe following are some examples:\nfirst in RPN,\nthen in infix notation,\nthen the output.\n\n**Tip**: Copy the RPN in the input and verify that the output is correct!\n\n| RPN                                    | **Infix Notation**             | **Output (Stack)** |\n|----------------------------------------|--------------------------------|--------------------|\n| `2 3 + 4 -`                            | `2 + 3 - 4`                    | `1`                |\n| `1 2 3 - - ~`                          | `-(1 - (2 - 3))`               | `-2`               |\n| `27 1 3 / ^`                           | `27^(1/3)`                     | `3`                |\n| `4 1 - 2 ^ 8 4 - 2 ^ + sqrt`           | `sqrt((4 - 1)^2 + (8 - 4)^2)`  | `5`                |\n| `-b b 2 ^ 4 a c * * - sqrt + 2 a * /`  | `(-b + sqrt(b^2-4ac))/(2a)`    | `NA`               |\n\n---\n\nAuthor: Jesse C. Chen ([jessekelighine.com](https://jessekelighine.com))\n<br>\n<br>\n","type":"text"},{"name":"www/style.css","content":"/* TABLE */\n\ntable {\n\tmargin: 0 auto;\n\tpadding: 10px;\n    border-collapse: collapse;\n}\n\ntr {\n    border-bottom: 1px solid #666666;\n}\n\ntr:nth-child(even) {\n\tbackground-color: #fdfdfd;\n}\n\ntd {\n\tpadding: 10px;\n}\n\nth {\n\ttext-align: left;\n\tbackground-color: #fbfbfb;\n\tpadding: 15px;\n\tborder-top: 2px solid #666666;\n\tborder-bottom: 2px solid #666666;\n}\n","type":"text"}]
